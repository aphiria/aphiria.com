<?php

/**
 * Aphiria
 *
 * @link      https://www.aphiria.com
 * @copyright Copyright (C) 2026 David Young
 * @license   https://github.com/aphiria/aphiria.com/blob/master/LICENSE.md
 */

declare(strict_types=1);

use App\Documentation\Searching\Context;
use App\Documentation\Searching\IndexEntry;
use App\Documentation\Searching\IndexingFailedException;
use Phinx\Seed\AbstractSeed;

class LexemeSeeder extends AbstractSeed
{
    /** @var array<string, string> The mapping of HTML elements to their weights (per PostgreSQL's setweight() function) */
    private static array $htmlElementsToWeights = [
        'h1' => 'A',
        'h2' => 'B',
        'h3' => 'C',
        'h4' => 'D',
        'h5' => 'D',
        'p' => 'D',
        'li' => 'D',
        'blockquote' => 'D',
    ];

    /**
     * @inheritdoc
     * @throws IndexingFailedException Thrown if indexing failed
     */
    public function run(): void
    {
        // First, remove all existing data within the table to start over fresh
        $this->execute('BEGIN');
        $this->output->writeln('Truncating lexemes');
        $this->execute('TRUNCATE TABLE lexemes');

        try {
            $indexEntries = $this->readLexemesFromNdjson();

            foreach ($indexEntries as $indexEntry) {
                $this->insertIndexEntry($indexEntry);
            }

            $this->updateLexemes();
            $this->execute('COMMIT');
        } catch (Throwable $ex) {
            $this->execute('ROLLBACK');

            throw new IndexingFailedException('Failed to index document: ' . $ex->getMessage(), 0, $ex);
        }
    }

    /**
     * Inserts an index entry into the database
     *
     * @param IndexEntry $indexEntry The entry to insert
     */
    private function insertIndexEntry(IndexEntry $indexEntry): void
    {
        $this->execute(
            <<<EOF
INSERT INTO lexemes (version, h1_inner_text, h2_inner_text, h3_inner_text, h4_inner_text, h5_inner_text, link, html_element_type, inner_text, html_element_weight, context)
VALUES (:version, :h1InnerText, :h2InnerText, :h3InnerText, :h4InnerText, :h5InnerText, :link, :htmlElementType, :innerText, :htmlElementWeight, :context)
EOF,
            [
                'version' => $indexEntry->version,
                'h1InnerText' => $indexEntry->h1InnerText,
                'h2InnerText' => $indexEntry->h2InnerText,
                'h3InnerText' => $indexEntry->h3InnerText,
                'h4InnerText' => $indexEntry->h4InnerText,
                'h5InnerText' => $indexEntry->h5InnerText,
                'link' => $indexEntry->link,
                'htmlElementType' => $indexEntry->htmlElementType,
                'innerText' => $indexEntry->innerText,
                'htmlElementWeight' => $indexEntry->htmlElementWeight,
                'context' => $indexEntry->context->value,
            ],
        );
    }

    /**
     * Read lexemes from NDJSON artifact generated by build-docs pipeline
     *
     * @return list<IndexEntry> The index entries
     * @throws IndexingFailedException Thrown if the NDJSON file cannot be read
     */
    private function readLexemesFromNdjson(): array
    {
        $ndjsonPath = __DIR__ . '/../../../../dist/docs/search/lexemes.ndjson';

        if (!\file_exists($ndjsonPath)) {
            throw new IndexingFailedException("Lexemes NDJSON file not found: $ndjsonPath");
        }

        $this->output->writeln("<info>Reading lexemes from $ndjsonPath</info>");
        $lines = \file($ndjsonPath, \FILE_IGNORE_NEW_LINES | \FILE_SKIP_EMPTY_LINES);

        if ($lines === false) {
            throw new IndexingFailedException("Failed to read NDJSON file: $ndjsonPath");
        }

        $indexEntries = [];

        foreach ($lines as $lineNumber => $line) {
            $lexeme = \json_decode($line, true);

            if ($lexeme === null) {
                throw new IndexingFailedException('Failed to parse JSON on line ' . ($lineNumber + 1) . ": $line");
            }

            // Map NDJSON lexeme record to IndexEntry
            // Apply weighting based on html_element_type
            $htmlElementType = $lexeme['html_element_type'];

            if (!isset(self::$htmlElementsToWeights[$htmlElementType])) {
                throw new IndexingFailedException("Unknown HTML element type: $htmlElementType");
            }

            $weight = self::$htmlElementsToWeights[$htmlElementType];

            // Map context string to enum
            $context = match ($lexeme['context']) {
                'framework' => Context::Framework,
                'library' => Context::Library,
                'global' => Context::Global,
                default => throw new IndexingFailedException("Unknown context: {$lexeme['context']}"),
            };

            $indexEntries[] = new IndexEntry(
                $lexeme['version'],
                $htmlElementType,
                $lexeme['inner_text'],
                $lexeme['link'],
                $weight,
                $context,
                $lexeme['h1_inner_text'],
                $lexeme['h2_inner_text'],
                $lexeme['h3_inner_text'],
                $lexeme['h4_inner_text'],
                $lexeme['h5_inner_text'],
            );
        }

        $this->output->writeln('<info>Loaded ' . \count($indexEntries) . ' lexemes</info>');

        return $indexEntries;
    }

    /**
     * Updates the lexemes in all our rows
     *
     * The tsvector includes both the element's inner_text (with its weight) and the heading hierarchy (h1-h5).
     * This allows boosting results where the search term appears in multiple heading levels.
     * For example, searching "routing" will rank "/docs/1.x/routing#route-attributes" (h1="Routing", h2="Route Attributes")
     * higher than "/docs/1.x/framework-comparisons#routing" (h1="Framework Comparison", h2="Routing")
     * because the first matches at both h1 AND h2 levels.
     */
    private function updateLexemes(): void
    {
        $h1Weight = self::$htmlElementsToWeights['h1'];
        $h2Weight = self::$htmlElementsToWeights['h2'];
        $h3Weight = self::$htmlElementsToWeights['h3'];
        $h4Weight = self::$htmlElementsToWeights['h4'];
        $h5Weight = self::$htmlElementsToWeights['h5'];

        $this->execute(
            <<<EOF
UPDATE lexemes SET
  english_lexemes =
    setweight(to_tsvector('english', COALESCE(h1_inner_text, '')), '{$h1Weight}') ||
    setweight(to_tsvector('english', COALESCE(h2_inner_text, '')), '{$h2Weight}') ||
    setweight(to_tsvector('english', COALESCE(h3_inner_text, '')), '{$h3Weight}') ||
    setweight(to_tsvector('english', COALESCE(h4_inner_text, '')), '{$h4Weight}') ||
    setweight(to_tsvector('english', COALESCE(h5_inner_text, '')), '{$h5Weight}') ||
    setweight(to_tsvector('english', COALESCE(inner_text, '')), html_element_weight::"char"),
  simple_lexemes =
    setweight(to_tsvector(COALESCE(h1_inner_text, '')), '{$h1Weight}') ||
    setweight(to_tsvector(COALESCE(h2_inner_text, '')), '{$h2Weight}') ||
    setweight(to_tsvector(COALESCE(h3_inner_text, '')), '{$h3Weight}') ||
    setweight(to_tsvector(COALESCE(h4_inner_text, '')), '{$h4Weight}') ||
    setweight(to_tsvector(COALESCE(h5_inner_text, '')), '{$h5Weight}') ||
    setweight(to_tsvector(COALESCE(inner_text, '')), html_element_weight::"char")
EOF,
        );
    }
}
