import { readFileSync } from "fs";
import { join } from "path";
import { DocPage } from "@/types/documentation";

/**
 * Get the repository root directory
 *
 * In development: cwd is apps/web, so go up 2 levels
 * In production Docker: cwd is /app, dist is at /app/dist
 */
function getRepoRoot(): string {
    const cwd = process.cwd();
    // If we're in apps/web, go up to repo root
    if (cwd.endsWith("apps/web")) {
        return join(cwd, "../..");
    }
    // Otherwise assume we're already at repo root (Docker build)
    return cwd;
}

// In-memory cache for doc metadata (static during runtime)
let metaCache: DocPage[] | null = null;

/**
 * Read doc metadata from compiled artifacts
 *
 * Reads from dist/docs/meta.json generated by tools/build-docs during Docker build
 * Cached in memory after first read (static content)
 */
export function readDocMeta(): DocPage[] {
    if (metaCache !== null) {
        return metaCache;
    }

    const metaPath = join(getRepoRoot(), "dist/docs/meta.json");

    try {
        const content = readFileSync(metaPath, "utf8");
        metaCache = JSON.parse(content) as DocPage[];
        return metaCache;
    } catch (error) {
        console.error("Failed to read doc metadata:", error);
        return [];
    }
}

// In-memory cache for doc HTML (static during runtime)
const htmlCache = new Map<string, string | null>();

/**
 * Read rendered HTML for a specific doc page
 *
 * Cached in memory after first read (static content)
 *
 * @param slug - Page slug (e.g., "installation")
 * @returns HTML content or null if not found
 */
export function readDocHtml(slug: string): string | null {
    if (htmlCache.has(slug)) {
        return htmlCache.get(slug)!;
    }

    const htmlPath = join(getRepoRoot(), "dist/docs/rendered", `${slug}.html`);

    try {
        const html = readFileSync(htmlPath, "utf8");
        htmlCache.set(slug, html);
        return html;
    } catch (error) {
        console.error(`Failed to read doc HTML for ${slug}:`, error);
        htmlCache.set(slug, null);
        return null;
    }
}

/**
 * Get all doc pages for a specific version
 *
 * @param version - Version identifier (e.g., "1.x")
 * @returns Array of doc pages
 */
export function getDocsForVersion(version: string): DocPage[] {
    const allDocs = readDocMeta();
    return allDocs.filter((doc) => doc.version === version);
}

/**
 * Clear all caches (for testing)
 *
 * @internal
 */
export function clearCaches(): void {
    metaCache = null;
    htmlCache.clear();
}
