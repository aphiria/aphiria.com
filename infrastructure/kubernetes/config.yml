# TODOS
# - Need to figure out how I can rerun pipelines and grab the latest documentation (that is currently happening in the Docker image)
# - Should automatically grab IP of load balancer (or the LB service??) and create an A record in TF (https://registry.terraform.io/providers/hashicorp/kubernetes/latest/docs/data-sources/service.html)
# - Use checksum/config annotation with Helm to auto-deploy pods on config map and secret updates
# - Need to encrypt my state file in S3
# - Figure out why Docker caching is not working.  Ideally, it's working even for JS and PHP package installation.
# - Provision my DO S3 instance via TF
# - Should I use Helm values to swap in local image names when testing k8s locally?
# - Need to figure out how I'll get wildcard TLS certs, which do not use the http method to check for the existence of a file
# - Add liveness probes to API.  I already have a /health endpoint to ping, but even though it's returning a 500, the probe is passing.  I should make sure that hitting /health on the nginx server is, in fact, returning the value from HealthController.
# - Should I add namespaces?
# - Use the following guide on using LetsEncrypt for real-world TLS certs. Note that it kind of mixes self-signed and real certs, so just pay attention.  https://someweb.github.io/devops/cert-manager-kubernetes/
# - Update README.md

# README Updates
# Log into Docker (docker login -u <username) and use an access token generated from docker.com
# Install kubectl, minikube, "minikube addons enable ingress" (needed every time minikube starts), add "127.0.0.1 aphiria.com" "127.0.0.1 www.aphiria.com" and "127.0.0.1 api.aphiria.com" to C:\Windows\System32\drivers\etc\hosts.
# Install Helm (https://helm.sh/docs/intro/install/)
# Install Terraform
  # - "cd /tmp"
  # - "wget https://releases.hashicorp.com/terraform/1.6.4/terraform_1.6.4_linux_amd64.zip" (make sure it's the latest version)
  # - "sudo unzip terraform_1.6.4_linux_amd64.zip -d /usr/local/bin"
  # - "terraform -v"
# Generate a Spaces token (not the same thing as an API token).  Be sure to copy the access token and the secret key to run the below commands.
# Run "terraform -chdir=./infrastructure/terraform init -backend-config="access_key=THE_SPACES_ACCESS_KEY" -backend-config="secret_key=THE_DO_SECRET_KEY"
# Run "terraform -chdir=./infrastructure/terraform plan", followed by "terraform -chdir=./infrastructure/terraform apply"
# - Start Minikube with "minikube start --force" (if using root user, otherwise `--force` is unnecessary), then grab its dashboard via "minikube dashboard", which needs to be run in a separate window because it's blocking.
# Build docker files, but first run "eval $(minikube -p minikube docker-env)" so that they're put in minikube's Docker repository
# "kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.2/cert-manager.yaml -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.0.0/standard-install.yaml -f infrastructure/kubernetes/config.yml -f infrastructure/kubernetes/secrets-dev.yml"
# Run "minikube dashboard" to pull up a GUI for minikube resources
# If running in WSL2, run "minikube tunnel" because Windows is considered external to WSL2, which is hosting minikube
# To get Chrome to accept self-signed cert for local test, type "thisisunsafe" on the page with the TLS warning

# Things I may need to do: delete cluster, re-install cert-manager using Helm (see old commit for instructions), run following:
# - "kubectl apply -f https://github.com/kubernetes-sigs/gateway-api/releases/download/v1.0.0/standard-install.yaml"
# - "helm upgrade --install nginx-gateway oci://ghcr.io/nginxinc/charts/nginx-gateway-fabric  --create-namespace --wait -n nginx-gateway"
# - "helm upgrade --install cert-manager jetstack/cert-manager --namespace cert-manager --create-namespace --version v1.13.2 --set installCRDs=true"



# Environment vars
apiVersion: v1
kind: ConfigMap
metadata:
  name: env-vars
data:
  APP_BUILDER_API: "\\Aphiria\\Framework\\Api\\SynchronousApiApplicationBuilder"
  APP_BUILDER_CONSOLE: "\\Aphiria\\Framework\\Console\\ConsoleApplicationBuilder"
  APP_ENV: production
  APP_WEB_URL: https://www.aphiria.com
  APP_API_URL: https://api.aphiria.com
  APP_COOKIE_DOMAIN: .aphiria.com
  APP_COOKIE_SECURE: "0"
  DB_HOST: db
  DB_NAME: postgres
  DB_PORT: "5432" # Make sure this matches the database service port
  DOC_LEXEMES_TABLE_NAME: ""
  LOG_LEVEL: debug

---
# JavaScript config
apiVersion: v1
kind: ConfigMap
metadata:
  name: js-config
data:
  config.js: |
    export default {
        apiUri: "https://api.aphiria.com"
    }

---
# Web deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web
spec:
  replicas: 1
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      containers:
        - name: web
          image: davidbyoung/aphiria.com-web:latest
          imagePullPolicy: IfNotPresent # TODO: This should be "Always" so I am getting the latest image, but manually loading the image into minikube via "minikube image load davidbyoung/aphiria.com-web:latest" is not working
          volumeMounts:
            - name: js-config
              mountPath: /usr/share/nginx/html/js/config
          livenessProbe:
            httpGet:
              path: /
              port: 80
          ports:
            - containerPort: 80
      volumes:
        - name: js-config
          configMap:
            name: js-config

---
# Web service
apiVersion: v1
kind: Service
metadata:
  name: web
spec:
  selector:
    app: web
  ports:
    - name: web
      protocol: TCP
      port: 80

---
# DB service
apiVersion: v1
kind: Service
metadata:
  name: db
spec:
  selector:
    app: db
  ports:
    - port: 5432 # Make sure this matches the DB_PORT environment var

---
# DB persistent volume
apiVersion: v1
kind: PersistentVolume
metadata:
  name: db-pv
  labels:
    app: db
spec:
  storageClassName: manual
  capacity:
    storage: 5Gi
  accessModes:
    - ReadWriteMany
  hostPath:
    path: /mnt/data

---
# DB persistent volume claim
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: db-pv-claim
  labels:
    app: db
spec:
  storageClassName: manual
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 5Gi

---
# DB deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: db
spec:
  replicas: 1
  selector:
    matchLabels:
      app: db
  template:
    metadata:
      labels:
        app: db
    spec:
      containers:
        - name: db
          image: postgres:16
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 5432 # Make sure this matches the DB_PORT environment var
          volumeMounts:
            - mountPath: /var/lib/postgresql/data
              name: db-data
          env:
          # These specific env vars are required for PostgreSQL to start up
          - name: POSTGRES_USER
            valueFrom:
              secretKeyRef:
                name: env-var-secrets
                key: DB_USER
          - name: POSTGRES_PASSWORD
            valueFrom:
              secretKeyRef:
                name: env-var-secrets
                key: DB_PASSWORD
          - name: PGDATA
            value: /var/lib/postgresql/data/pgdata
          readinessProbe:
            exec:
              # Make sure the port matches the DB_PORT environment var
              command: [ 'pg_isready', '-U', '$(POSTGRES_USER)', '-d', '$(POSTGRES_DB)', '-h', '127.0.0.1', '-p', '5432']
            initialDelaySeconds: 5
            periodSeconds: 10
            timeoutSeconds: 5
            successThreshold: 1
            failureThreshold: 5
      volumes:
        - name: db-data
          persistentVolumeClaim:
            claimName: db-pv-claim

---
# API service
apiVersion: v1
kind: Service
metadata:
  name: api
spec:
  selector:
    app: api
  ports:
    - name: api
      protocol: TCP
      port: 80
    - name: fastcgi
      protocol: TCP
      port: 9000
      targetPort: 9000

---
# API deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api
spec:
  replicas: 1
  selector:
    matchLabels:
      app: api
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: api
    spec:
      # Copy the PHP source code into a shared volume that is mounted to PHP-FPM and nginx
      initContainers:
        - name: copy-api-code
          image: davidbyoung/aphiria.com-api:latest
          imagePullPolicy: IfNotPresent # TODO: This should be "Always" so I am getting the latest image, but manually loading the image into minikube via "minikube image load davidbyoung/aphiria.com-api:latest" is not working
          # We copy and preserve the permissions so that nginx has access to things like the tmp directory
          command: [ 'sh', '-c', 'cp -Rp /app/api/. /usr/share/nginx/html' ]
          volumeMounts:
            - name: api-code
              mountPath: /usr/share/nginx/html
      containers:
        - name: nginx
          image: nginx:alpine
          ports:
            - containerPort: 80
          volumeMounts:
            - name: api-code
              mountPath: /usr/share/nginx/html
            - name: nginx-config
              mountPath: /etc/nginx/conf.d/default.conf
              subPath: default.conf
        - name: php
          image: davidbyoung/aphiria.com-api:latest
          imagePullPolicy: IfNotPresent # TODO: This should be "Always" so I am getting the latest image, but manually loading the image into minikube via "minikube image load davidbyoung/aphiria.com-api:latest" is not working
          ports:
            - containerPort: 9000
          envFrom:
            - secretRef:
                name: env-var-secrets
            - configMapRef:
                name: env-vars
          volumeMounts:
            - name: api-code
              mountPath: /usr/share/nginx/html
      volumes:
        - name: api-code
          emptyDir: {}
        - name: nginx-config
          configMap:
            name: nginx-config
            items:
              - key: default.conf
                path: default.conf

---
# DB migration job
apiVersion: batch/v1
kind: Job
metadata:
  name: db-migration
spec:
  template:
    spec:
      containers:
        - name: db-migration
          image: davidbyoung/aphiria.com-api:latest
          imagePullPolicy: IfNotPresent
          command: ['php', '/app/api/aphiria', 'docs:index']
          envFrom:
            - secretRef:
                name: env-var-secrets
            - configMapRef:
                name: env-vars
      restartPolicy: Never

---
# nginx config to serve PHP files
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
data:
  default.conf: |
    server {
        index index.php index.html;
        error_log  /var/log/nginx/error.log;
        access_log /var/log/nginx/access.log;
        root /usr/share/nginx/html/public;
        add_header X-Frame-Options "SAMEORIGIN";
        add_header X-XSS-Protection "1; mode=block";
        add_header X-Content-Type-Options "nosniff";

        location / {
            try_files $uri $uri/ /index.php$is_args$args;
        }

        location ~ \.php$ {
            fastcgi_split_path_info ^(.+\.php)(/.+)$;
            # Pass this through to the PHP image running in this pod on port 9000
            fastcgi_pass 127.0.0.1:9000;
            fastcgi_index index.php;
            include fastcgi_params;
            fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
            fastcgi_param PATH_INFO $fastcgi_path_info;
            fastcgi_hide_header X-Powered-By;
        }
    }


---
# Self-signed certificate cluster issuer
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: selfsigned-issuer
  namespace: nginx-gateway
spec:
  selfSigned: {}

---
# Self-signed certificate
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: selfsigned-crt
  namespace: nginx-gateway
spec:
  secretName: tls-secret
  duration: 170000h
  renewBefore: 72h
  issuerRef:
    kind: ClusterIssuer
    name: selfsigned-issuer
  commonName: "*.aphiria.com"
  isCA: true
  dnsNames:
    - www.aphiria.com
    - api.aphiria.com
---
# Gateway API service
apiVersion: v1
kind: Service
metadata:
  name: nginx-gateway
  namespace: nginx-gateway
  labels:
    app.kubernetes.io/name: nginx-gateway
    app.kubernetes.io/instance: nginx-gateway
    app.kubernetes.io/version: "1.0.0"
spec:
  type: NodePort
  selector:
    app.kubernetes.io/name: nginx-gateway
    app.kubernetes.io/instance: nginx-gateway
  ports:
    - name: http
      port: 80
      protocol: TCP
      targetPort: 80
    - name: https
      port: 443
      protocol: TCP
      targetPort: 443

---
# Gateway API
apiVersion: gateway.networking.k8s.io/v1
kind: Gateway
metadata:
  name: nginx-gateway
  namespace: nginx-gateway
spec:
  gatewayClassName: nginx
  listeners:
    - name: http
      port: 80
      protocol: HTTP
      hostname: "*.aphiria.com"
      allowedRoutes:
        namespaces:
          from: All
    - name: https
      port: 443
      protocol: HTTPS
      hostname: "*.aphiria.com"
      allowedRoutes:
        namespaces:
          from: All
      tls:
        mode: Terminate
        certificateRefs:
          - kind: Secret
            name: tls-secret
    - name: https-without-www
      port: 443
      protocol: HTTPS
      hostname: aphiria.com
      allowedRoutes:
        namespaces:
          from: All
      tls:
        mode: Terminate
        certificateRefs:
          - kind: Secret
            name: tls-secret

---
# Route api to API
apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata:
  name: api
spec:
  hostnames:
    - api.aphiria.com
  parentRefs:
    - name: nginx-gateway
      namespace: nginx-gateway
  rules:
    - backendRefs:
        - name: api
          port: 80
      matches:
        - path:
            type: PathPrefix
            value: /

---
# Route www to web
apiVersion: gateway.networking.k8s.io/v1
kind: HTTPRoute
metadata:
  name: web
spec:
  hostnames:
    - www.aphiria.com
  parentRefs:
    - name: nginx-gateway
      namespace: nginx-gateway
  rules:
    - backendRefs:
        - name: web
          port: 80
      matches:
        - path:
            type: PathPrefix
            value: /

---
# Redirect http to https
apiVersion: gateway.networking.k8s.io/v1beta1
kind: HTTPRoute
metadata:
  name: https-redirect
spec:
  parentRefs:
    - name: nginx-gateway
      namespace: nginx-gateway
      sectionName: http
  hostnames:
    - "*.aphiria.com"
  rules:
    - filters:
        - type: RequestRedirect
          requestRedirect:
            scheme: https
            port: 443

---
# Redirect aphiria.com to www.aphiria.com
apiVersion: gateway.networking.k8s.io/v1beta1
kind: HTTPRoute
metadata:
  name: www-redirect
spec:
  parentRefs:
    - name: nginx-gateway
      namespace: nginx-gateway
      sectionName: https-without-www
  hostnames:
    - aphiria.com
  rules:
    - filters:
        - type: RequestRedirect
          requestRedirect:
            scheme: https
            hostname: www.aphiria.com
            port: 443
