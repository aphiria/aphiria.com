# TODOS
# - Determine why the API returns 500 responses and why I don't see error logs for them.
# - Refactor documentation lexing to not touch .env file
# - Add configMap to pull in prod URLs into config.js
# - Add a "Job" to run DB migrations with
# - Need to totally overhaul how I am currently creating new lexeme tables and storing them in the .env file
# - Can/should I set the domains to something like api.aphiria.local and aphiria.local, and swap in the prod values when deploying?  What's SOP?
# - Add liveness probes to API.  I already have a /health endpoint to ping, but even though it's returning a 500, the probe is passing.  I should make sure that hitting /health on the nginx server is, in fact, returning the value from HealthController.
# - Should I add namespaces?
# - Update README.md

# README Updates
# Install kubectl, minikube, "minikube addons enable ingress" (needed every time minikube starts), add "127.0.0.1 aphiria.com" "127.0.0.1 www.aphiria.com" and "127.0.0.1 api.aphiria.com" to C:\Windows\System32\drivers\etc\hosts.
# Build docker files, but first run "eval $(minikube -p minikube docker-env)" so that they're put in minikube's Docker repository
# kubectl apply -f kubernetes/config.yml
# Run "minikube dashboard" to pull up a GUI for minikube resources
# If running in WSL2, run "minikube tunnel" because Windows is considered external to WSL2, which is hosting minikube


# Secret environment vars
apiVersion: v1
kind: Secret
metadata:
  name: env-var-secrets
stringData:
  DB_USER: testuser # TODO:  Store this as a secret in GitHub
  DB_PASSWORD: testpassword # TODO:  Store this as a secret in GitHub

---
# Environment vars
apiVersion: v1
kind: ConfigMap
metadata:
  name: env-vars
  labels:
    app: env-vars
data:
  APP_BUILDER_API: "\\Aphiria\\Framework\\Api\\SynchronousApiApplicationBuilder"
  APP_BUILDER_CONSOLE: "\\Aphiria\\Framework\\Console\\ConsoleApplicationBuilder"
  APP_ENV: production
  APP_WEB_URL: http://www.aphiria.com # TODO: Should be https
  APP_API_URL: http://api.aphiria.com # TODO: Should be https
  APP_COOKIE_DOMAIN: .aphiria.com
  APP_COOKIE_SECURE: "0"
  DB_HOST: db
  DB_NAME: postgres
  DB_PORT: "5432" # Make sure this matches the database service port
  DOC_LEXEMES_TABLE_NAME: ""
  LOG_LEVEL: debug

---
# Web deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web
spec:
  replicas: 1
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      containers:
        - name: web
          image: aphiria.com-web:latest
          imagePullPolicy: IfNotPresent # TODO: This should be "Always" so I am getting the latest image, but manually loading the image into minikube via "minikube image load aphiria.com-web:latest" is not working
          livenessProbe:
            httpGet:
              path: /
              port: 80
          ports:
            - containerPort: 80

---
# Web service
apiVersion: v1
kind: Service
metadata:
  name: web
spec:
  selector:
    app: web
  ports:
    - name: web
      protocol: TCP
      port: 80

---
# DB service
apiVersion: v1
kind: Service
metadata:
  name: db
spec:
  selector:
    app: db
  ports:
    - port: 5432 # Make sure this matches the DB_PORT environment var

---
# DB persistent volume
apiVersion: v1
kind: PersistentVolume
metadata:
  name: db-pv
  labels:
    type: local
    app: db
spec:
  storageClassName: manual
  capacity:
    storage: 5Gi
  accessModes:
    - ReadWriteMany
  hostPath:
    path: /mnt/data

---
# DB persistent volume claim
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: db-pv-claim
  labels:
    app: db
spec:
  storageClassName: manual
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 5Gi

---
# DB deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: db
spec:
  replicas: 1
  selector:
    matchLabels:
      app: db
  template:
    metadata:
      labels:
        app: db
    spec:
      containers:
        - name: db
          image: postgres:16
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 5432 # Make sure this matches the DB_PORT environment var
          volumeMounts:
            - mountPath: /var/lib/postgresql/data
              name: db-data
          env:
          # These specific env vars are required for PostgreSQL to start up
          - name: POSTGRES_USER
            valueFrom:
              secretKeyRef:
                name: env-var-secrets
                key: DB_USER
          - name: POSTGRES_PASSWORD
            valueFrom:
              secretKeyRef:
                name: env-var-secrets
                key: DB_PASSWORD
          - name: PGDATA
            value: /var/lib/postgresql/data/pgdata
          readinessProbe:
            exec:
              # Make sure the port matches the DB_PORT environment var
              command: [ 'pg_isready', '-U', '$(POSTGRES_USER)', '-d', '$(POSTGRES_DB)', '-h', '127.0.0.1', '-p', '5432']
            initialDelaySeconds: 5
            periodSeconds: 10
            timeoutSeconds: 5
            successThreshold: 1
            failureThreshold: 5
      volumes:
        - name: db-data
          persistentVolumeClaim:
            claimName: db-pv-claim

---
# Ingress controller
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: nginx-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/from-to-www-redirect: "true"
spec:
  ingressClassName: nginx
  rules:
    - host: api.aphiria.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: api
                port:
                  name: api
    - host: www.aphiria.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: web
                port:
                  name: web

---
# API service
apiVersion: v1
kind: Service
metadata:
  name: api
spec:
  selector:
    app: api
  ports:
    - name: api
      protocol: TCP
      port: 80
    - name: fastcgi
      protocol: TCP
      port: 9000
      targetPort: 9000

---
# API deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api
spec:
  replicas: 1
  selector:
    matchLabels:
      app: api
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: api
    spec:
      # Copy the PHP source code into a shared volume that is mounted to PHP-FPM and nginx
      initContainers:
        - name: copy-api-code
          image: aphiria.com-api:latest
          imagePullPolicy: IfNotPresent # TODO: This should be "Always" so I am getting the latest image, but manually loading the image into minikube via "minikube image load aphiria.com-api:latest" is not working
          # We copy and preserve the permissions so that nginx has access to things like the tmp directory
          command: [ 'sh', '-c', 'cp -Rp /app/api/. /usr/share/nginx/html' ]
          volumeMounts:
            - name: api-code
              mountPath: /usr/share/nginx/html
      containers:
        - name: nginx
          image: nginx:alpine
          ports:
            - containerPort: 80
          volumeMounts:
            - name: api-code
              mountPath: /usr/share/nginx/html
            - name: nginx-config
              mountPath: /etc/nginx/conf.d/default.conf
              subPath: default.conf
        - name: php
          image: aphiria.com-api:latest
          imagePullPolicy: IfNotPresent # TODO: This should be "Always" so I am getting the latest image, but manually loading the image into minikube via "minikube image load aphiria.com-api:latest" is not working
          ports:
            - containerPort: 9000
          envFrom:
            - secretRef:
                name: env-var-secrets
            - configMapRef:
                name: env-vars
          volumeMounts:
            - name: api-code
              mountPath: /usr/share/nginx/html
      volumes:
        - name: api-code
          emptyDir: {}
        - name: nginx-config
          configMap:
            name: nginx-config
            items:
              - key: default.conf
                path: default.conf

---
# nginx config to serve PHP files
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
data:
  default.conf: |
    server {
        index index.php index.html;
        error_log  /var/log/nginx/error.log;
        access_log /var/log/nginx/access.log;
        root /usr/share/nginx/html/public;
        add_header X-Frame-Options "SAMEORIGIN";
        add_header X-XSS-Protection "1; mode=block";
        add_header X-Content-Type-Options "nosniff";

        location / {
            try_files $uri $uri/ /index.php$is_args$args;
        }

        location ~ \.php$ {
            #try_files $uri =404;
            fastcgi_split_path_info ^(.+\.php)(/.+)$;
            # Pass this through to the PHP image running in this pod on port 9000
            fastcgi_pass 127.0.0.1:9000;
            fastcgi_index index.php;
            include fastcgi_params;
            fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
            fastcgi_param PATH_INFO $fastcgi_path_info;
            fastcgi_hide_header X-Powered-By;
        }
    }
