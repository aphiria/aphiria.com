# TODOS
# - Figure out why Docker caching is not working.  Ideally, it's working even for JS and PHP package installation.
# - Deploy to k8s cluster
# - What should the directory structure be for k8s, docker, and terraform?  What's standard?
# - Need to figure out how I'd manage secrets in the real world
# - Should I use Helm values to swap in local image names when testing k8s locally?
# - Need to figure out how I'll get wildcard TLS certs, which do not use the http method to check for the existence of a file
# - In CI, we need to delete and re-apply the migration job
# - In CI, need to enable nginx ingress addon
# - In CI, need to determine how I can install charts
# - Helm commands to get the cert manager set up:
#     helm repo add jetstack https://charts.jetstack.io
#     helm repo update
#     helm install cert-manager jetstack/cert-manager --namespace cert-manager --create-namespace --version v1.13.2 --set installCRDs=true
# - Add liveness probes to API.  I already have a /health endpoint to ping, but even though it's returning a 500, the probe is passing.  I should make sure that hitting /health on the nginx server is, in fact, returning the value from HealthController.
# - Should I add namespaces?
# - Use the following guide on using LetsEncrypt for real-world TLS certs. Note that it kind of mixes self-signed and real certs, so just pay attention.  https://someweb.github.io/devops/cert-manager-kubernetes/
# - Update README.md

# README Updates
# Install kubectl, minikube, "minikube addons enable ingress" (needed every time minikube starts), add "127.0.0.1 aphiria.com" "127.0.0.1 www.aphiria.com" and "127.0.0.1 api.aphiria.com" to C:\Windows\System32\drivers\etc\hosts.
# Install Helm (https://helm.sh/docs/intro/install/)
# Install Terraform
  # - "cd /tmp"
  # - "wget https://releases.hashicorp.com/terraform/1.6.4/terraform_1.6.4_linux_a
#md64.zip" (make sure it's the latest version)
  # - "sudo unzip terraform_1.6.4_linux_amd64.zip -d /usr/local/bin"
  # - "terraform -v"
# Add a "terraform.tfvars" with variable values (see work Laptop for structure).  Note that these vars are configured via CLI args during CI/CD.
# Generate a Spaces token (not the same thing as an API token).  Be sure to copy the access token and the secret key to run the below commands.
# Run "terraform init -backend-config="access_key=THE_SPACES_ACCESS_KEY" -backend-config="secret_key=THE_DO_SECRET_KEY"
# Run "terraform plan", followed by "terraform apply"
# Build docker files, but first run "eval $(minikube -p minikube docker-env)" so that they're put in minikube's Docker repository
# "kubectl apply -f kubernetes/config.yml -f kubernetes/secrets-dev.yml"
# Run "minikube dashboard" to pull up a GUI for minikube resources
# If running in WSL2, run "minikube tunnel" because Windows is considered external to WSL2, which is hosting minikube
# ConfigMaps and Secrets getting updated doesn't automatically trigger dependent deployments getting re-deployed.  You'd need something like https://github.com/stakater/Reloader/ to do this.  Beyond that, you just have to delete the deployment and redeploy to get changes to take.
# To get Chrome to accept self-signed cert for local test, type "thisisunsafe" on the page with the TLS warning


# Environment vars
apiVersion: v1
kind: ConfigMap
metadata:
  name: env-vars
data:
  APP_BUILDER_API: "\\Aphiria\\Framework\\Api\\SynchronousApiApplicationBuilder"
  APP_BUILDER_CONSOLE: "\\Aphiria\\Framework\\Console\\ConsoleApplicationBuilder"
  APP_ENV: production
  APP_WEB_URL: https://www.aphiria.com
  APP_API_URL: https://api.aphiria.com
  APP_COOKIE_DOMAIN: .aphiria.com
  APP_COOKIE_SECURE: "0"
  DB_HOST: db
  DB_NAME: postgres
  DB_PORT: "5432" # Make sure this matches the database service port
  DOC_LEXEMES_TABLE_NAME: ""
  LOG_LEVEL: debug

---
# JavaScript config
apiVersion: v1
kind: ConfigMap
metadata:
  name: js-config
data:
  config.js: |
    export default {
        apiUri: "https://api.aphiria.com"
    }

---
# Web deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web
spec:
  replicas: 1
  selector:
    matchLabels:
      app: web
  template:
    metadata:
      labels:
        app: web
    spec:
      containers:
        - name: web
          image: davidbyoung/aphiria.com-web:latest
          imagePullPolicy: IfNotPresent # TODO: This should be "Always" so I am getting the latest image, but manually loading the image into minikube via "minikube image load davidbyoung/aphiria.com-web:latest" is not working
          volumeMounts:
            - name: js-config
              mountPath: /usr/share/nginx/html/js/config
          livenessProbe:
            httpGet:
              path: /
              port: 80
          ports:
            - containerPort: 80
      volumes:
        - name: js-config
          configMap:
            name: js-config

---
# Web service
apiVersion: v1
kind: Service
metadata:
  name: web
spec:
  selector:
    app: web
  ports:
    - name: web
      protocol: TCP
      port: 80

---
# DB service
apiVersion: v1
kind: Service
metadata:
  name: db
spec:
  selector:
    app: db
  ports:
    - port: 5432 # Make sure this matches the DB_PORT environment var

---
# DB persistent volume
apiVersion: v1
kind: PersistentVolume
metadata:
  name: db-pv
  labels:
    app: db
spec:
  storageClassName: manual
  capacity:
    storage: 5Gi
  accessModes:
    - ReadWriteMany
  hostPath:
    path: /mnt/data

---
# DB persistent volume claim
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: db-pv-claim
  labels:
    app: db
spec:
  storageClassName: manual
  accessModes:
    - ReadWriteMany
  resources:
    requests:
      storage: 5Gi

---
# DB deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: db
spec:
  replicas: 1
  selector:
    matchLabels:
      app: db
  template:
    metadata:
      labels:
        app: db
    spec:
      containers:
        - name: db
          image: postgres:16
          imagePullPolicy: IfNotPresent
          ports:
            - containerPort: 5432 # Make sure this matches the DB_PORT environment var
          volumeMounts:
            - mountPath: /var/lib/postgresql/data
              name: db-data
          env:
          # These specific env vars are required for PostgreSQL to start up
          - name: POSTGRES_USER
            valueFrom:
              secretKeyRef:
                name: env-var-secrets
                key: DB_USER
          - name: POSTGRES_PASSWORD
            valueFrom:
              secretKeyRef:
                name: env-var-secrets
                key: DB_PASSWORD
          - name: PGDATA
            value: /var/lib/postgresql/data/pgdata
          readinessProbe:
            exec:
              # Make sure the port matches the DB_PORT environment var
              command: [ 'pg_isready', '-U', '$(POSTGRES_USER)', '-d', '$(POSTGRES_DB)', '-h', '127.0.0.1', '-p', '5432']
            initialDelaySeconds: 5
            periodSeconds: 10
            timeoutSeconds: 5
            successThreshold: 1
            failureThreshold: 5
      volumes:
        - name: db-data
          persistentVolumeClaim:
            claimName: db-pv-claim

---
# Ingress controller
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: nginx-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/from-to-www-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"
    cert-manager.io/cluster-issuer: selfsigned-issuer
spec:
  ingressClassName: nginx
  rules:
    - host: api.aphiria.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: api
                port:
                  name: api
    - host: www.aphiria.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: web
                port:
                  name: web
  tls:
    - hosts:
        - www.aphiria.com
        - api.aphiria.com
      secretName: tls-secret

---
# API service
apiVersion: v1
kind: Service
metadata:
  name: api
spec:
  selector:
    app: api
  ports:
    - name: api
      protocol: TCP
      port: 80
    - name: fastcgi
      protocol: TCP
      port: 9000
      targetPort: 9000

---
# API deployment
apiVersion: apps/v1
kind: Deployment
metadata:
  name: api
spec:
  replicas: 1
  selector:
    matchLabels:
      app: api
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: api
    spec:
      # Copy the PHP source code into a shared volume that is mounted to PHP-FPM and nginx
      initContainers:
        - name: copy-api-code
          image: davidbyoung/aphiria.com-api:latest
          imagePullPolicy: IfNotPresent # TODO: This should be "Always" so I am getting the latest image, but manually loading the image into minikube via "minikube image load davidbyoung/aphiria.com-api:latest" is not working
          # We copy and preserve the permissions so that nginx has access to things like the tmp directory
          command: [ 'sh', '-c', 'cp -Rp /app/api/. /usr/share/nginx/html' ]
          volumeMounts:
            - name: api-code
              mountPath: /usr/share/nginx/html
      containers:
        - name: nginx
          image: nginx:alpine
          ports:
            - containerPort: 80
          volumeMounts:
            - name: api-code
              mountPath: /usr/share/nginx/html
            - name: nginx-config
              mountPath: /etc/nginx/conf.d/default.conf
              subPath: default.conf
        - name: php
          image: davidbyoung/aphiria.com-api:latest
          imagePullPolicy: IfNotPresent # TODO: This should be "Always" so I am getting the latest image, but manually loading the image into minikube via "minikube image load davidbyoung/aphiria.com-api:latest" is not working
          ports:
            - containerPort: 9000
          envFrom:
            - secretRef:
                name: env-var-secrets
            - configMapRef:
                name: env-vars
          volumeMounts:
            - name: api-code
              mountPath: /usr/share/nginx/html
      volumes:
        - name: api-code
          emptyDir: {}
        - name: nginx-config
          configMap:
            name: nginx-config
            items:
              - key: default.conf
                path: default.conf

---
# DB migration job
apiVersion: batch/v1
kind: Job
metadata:
  name: db-migration
spec:
  template:
    spec:
      containers:
        - name: db-migration
          image: davidbyoung/aphiria.com-api:latest
          imagePullPolicy: IfNotPresent
          command: ['php', '/app/api/aphiria', 'docs:index']
          envFrom:
            - secretRef:
                name: env-var-secrets
            - configMapRef:
                name: env-vars
      restartPolicy: Never

---
# nginx config to serve PHP files
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
data:
  default.conf: |
    server {
        index index.php index.html;
        error_log  /var/log/nginx/error.log;
        access_log /var/log/nginx/access.log;
        root /usr/share/nginx/html/public;
        add_header X-Frame-Options "SAMEORIGIN";
        add_header X-XSS-Protection "1; mode=block";
        add_header X-Content-Type-Options "nosniff";

        location / {
            try_files $uri $uri/ /index.php$is_args$args;
        }

        location ~ \.php$ {
            fastcgi_split_path_info ^(.+\.php)(/.+)$;
            # Pass this through to the PHP image running in this pod on port 9000
            fastcgi_pass 127.0.0.1:9000;
            fastcgi_index index.php;
            include fastcgi_params;
            fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
            fastcgi_param PATH_INFO $fastcgi_path_info;
            fastcgi_hide_header X-Powered-By;
        }
    }


---
# Self-signed certificate cluster issuer
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: selfsigned-issuer
spec:
  selfSigned: {}

---
# Self-signed certificate
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: selfsigned-crt
spec:
  secretName: tls-secret
  duration: 170000h
  renewBefore: 72h
  issuerRef:
    kind: Issuer
    name: selfsigned-issuer
  commonName: "*.aphiria.com"
  isCA: true
  dnsNames:
    - www.aphiria.com
    - api.aphiria.com
